if (typeof __ !== 'function') {
    window.__ = function(text, params) {
        if (!params) return text;
        return text.replace(/{([^}]+)}/g, function(match, key) {
            return typeof params[key] !== 'undefined' ? params[key] : match;
        });
    };
}

class AudioRecorder {
    constructor() {
        this.mediaRecorder = null;
        this.audioChunks = [];
        this.audioBlob = null;
        this.audioUrl = null;
        this.audioElement = null;
        this.stream = null;
        this.isRecording = false;
        this.isPaused = false;
        this.startTime = null;
        this.elapsedTime = 0;
        this.pausedTime = 0;
        this.timerInterval = null;
        this.visualizerInterval = null;
        this.analyser = null;
        this.dataArray = null;
        this.canvasCtx = null;
        
        this.supportsPauseResume = false;
        this.pauseWorkaround = false;
        this.tempChunks = [];
    }

    async startRecording() {
        try {
            this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            
            const hasMediaRecorderPauseSupport = typeof MediaRecorder !== 'undefined' && 
                                               typeof MediaRecorder.prototype.pause === 'function' && 
                                               typeof MediaRecorder.prototype.resume === 'function';
            
            this.supportsPauseResume = hasMediaRecorderPauseSupport;
            
            this.pauseWorkaround = !hasMediaRecorderPauseSupport;
            
            let options = {};
            if (MediaRecorder.isTypeSupported('audio/mp3')) {
                options = { mimeType: 'audio/mp3' };
            } else if (MediaRecorder.isTypeSupported('audio/webm')) {
                options = { mimeType: 'audio/webm' };
            }
            this.mediaRecorder = new MediaRecorder(this.stream, options);
            this.audioChunks = [];

            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(this.stream);
            this.analyser = audioContext.createAnalyser();
            this.analyser.fftSize = 256;
            source.connect(this.analyser);
            const bufferLength = this.analyser.frequencyBinCount;
            this.dataArray = new Uint8Array(bufferLength);

            const canvas = document.getElementById('audio-visualizer');
            if (canvas) {
                this.canvasCtx = canvas.getContext('2d');
            }

            this.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    this.audioChunks.push(event.data);
                }
            };

            this.mediaRecorder.onstop = () => {
                const mimeType = this.mediaRecorder.mimeType || 'audio/webm';
                this.audioBlob = new Blob(this.audioChunks, { type: mimeType });
                this.audioUrl = URL.createObjectURL(this.audioBlob);
            };

            this.mediaRecorder.start(200);
            this.isRecording = true;
            this.isPaused = false;
            this.startTime = new Date();
            this.elapsedTime = 0;
            this.pausedTime = 0;

            this.startTimer();
            
            this.startVisualizer();
            
            const recordingInterface = document.querySelector('.audio-recording-interface');
            if (recordingInterface) {
                recordingInterface.classList.add('is-recording');
            }
            
            document.querySelectorAll('.extra-fields-container').forEach(el => el.classList.add('hidden'));
            
            return true;
        } catch (error) {
            console.error('Error starting recording:', error);
            if (typeof toastr !== 'undefined') {
                const micPermissionMsg = __('Could not access the microphone. Check your browser permissions.');
                toastr.error(micPermissionMsg);
            } else {
                const micPermissionMsg = __('Could not access the microphone. Check your browser permissions.');
                alert(micPermissionMsg);
            }
            return false;
        }
    }

    pauseRecording() {
        if (this.isRecording && !this.isPaused && this.mediaRecorder) {
            try {
                if (this.supportsPauseResume) {
                    this.mediaRecorder.pause();
                } else if (this.pauseWorkaround) {
                    this.tempChunks = [...this.audioChunks];
                    this.stream.getAudioTracks().forEach(track => {
                        track.enabled = false;
                    });
                }
                
                if (this.startTime) {
                    this.elapsedTime += Math.floor((new Date() - this.startTime) / 1000);
                }
                this.startTime = null;
                this.isPaused = true;
                
                this.stopVisualizer();
                
                const recordingInterface = document.querySelector('.audio-recording-interface');
                if (recordingInterface) {
                    recordingInterface.classList.remove('is-recording');
                }
                
                return true;
            } catch (error) {
                console.error('Error pausing recording:', error);
                return false;
            }
        }
        return false;
    }

    resumeRecording() {
        if (this.isRecording && this.isPaused && this.mediaRecorder) {
            try {
                if (this.supportsPauseResume) {
                    this.mediaRecorder.resume();
                } else if (this.pauseWorkaround) {
                    this.stream.getAudioTracks().forEach(track => {
                        track.enabled = true;
                    });
                }
                
                this.startTime = new Date();
                this.isPaused = false;
                
                this.startTimer();
                this.startVisualizer();
                
                const recordingInterface = document.querySelector('.audio-recording-interface');
                if (recordingInterface) {
                    recordingInterface.classList.add('is-recording');
                }
                
                return true;
            } catch (error) {
                console.error('Error resuming recording:', error);
                return false;
            }
        }
        return false;
    }

    stopRecording() {
        if (this.isRecording && this.mediaRecorder) {
            try {
                if (this.isPaused && this.pauseWorkaround) {
                    this.stream.getAudioTracks().forEach(track => {
                        track.enabled = true;
                    });
                }
                
                this.mediaRecorder.stop();
                this.isRecording = false;
                this.isPaused = false;
                
                clearInterval(this.timerInterval);
                
                this.stopVisualizer();
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                }
                
                const recordingInterface = document.querySelector('.audio-recording-interface');
                if (recordingInterface) {
                    recordingInterface.classList.remove('is-recording');
                }
                
                return true;
            } catch (error) {
                console.error('Error stopping recording:', error);
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                }
                
                this.isRecording = false;
                this.isPaused = false;
                return false;
            }
        }
        return false;
    }

    cancelRecording() {
        this.stopRecording();
        
        this.audioChunks = [];
        this.audioBlob = null;
        this.audioUrl = null;
        
        return true;
    }

    getAudioBlob() {
        return this.audioBlob;
    }

    startTimer() {
        clearInterval(this.timerInterval);
        this.updateTimerDisplay();
        this.timerInterval = setInterval(() => {
            this.updateTimerDisplay();
        }, 1000);
    }

    updateTimerDisplay() {
        let totalElapsedTime = this.elapsedTime;
        if (!this.isPaused && this.startTime) {
            totalElapsedTime += Math.floor((new Date() - this.startTime) / 1000);
        }

        const hours = Math.floor(totalElapsedTime / 3600);
        const minutes = Math.floor((totalElapsedTime % 3600) / 60);
        const seconds = totalElapsedTime % 60;
        
        let formattedTime;
        if (hours > 0) {
            formattedTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        } else {
            formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        const timerElement = document.getElementById('recording-timer');
        if (timerElement) {
            timerElement.textContent = formattedTime;
        }
        
        const sendButton = document.getElementById('send-recording');
        if (sendButton) {
            if (totalElapsedTime >= 5) {
                sendButton.disabled = false;
                sendButton.title = __('Send recording');
            } else {
                sendButton.disabled = true;
                sendButton.title = __('Recording too short (minimum 5 seconds). 5 second(s) left.');
            }
        }
    }

    startVisualizer() {
        this._visualizerActive = true;
        const animate = () => {
            if (!this._visualizerActive) return;
            this.drawVisualizer();
            this._visualizerFrame = requestAnimationFrame(animate);
        };
        if (this._visualizerFrame) {
            cancelAnimationFrame(this._visualizerFrame);
        }
        animate();
    }

    stopVisualizer() {
        this._visualizerActive = false;
        if (this._visualizerFrame) {
            cancelAnimationFrame(this._visualizerFrame);
            this._visualizerFrame = null;
        }
    }

    drawVisualizer() {
        if (!this.analyser || !this.canvasCtx || !this.dataArray) return;
        
        const ctx = this.canvasCtx;
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;

        ctx.save();
        const radius = height / 2;
        ctx.beginPath();
        ctx.moveTo(radius, 0);
        ctx.lineTo(width - radius, 0);
        ctx.quadraticCurveTo(width, 0, width, radius);
        ctx.lineTo(width, height - radius);
        ctx.quadraticCurveTo(width, height, width - radius, height);
        ctx.lineTo(radius, height);
        ctx.quadraticCurveTo(0, height, 0, height - radius);
        ctx.lineTo(0, radius);
        ctx.quadraticCurveTo(0, 0, radius, 0);
        ctx.closePath();
        ctx.clip();

        ctx.clearRect(0, 0, width, height);

        const numBars = 160;
        const numDots = 16;
        const barWidth = width / numBars;
        const maxBarHeight = height * 0.9;
        this.analyser.getByteFrequencyData(this.dataArray);
        
        const isDarkMode = document.documentElement.classList.contains('dark') || 
                          document.documentElement.classList.contains('theme-dark') ||
                          document.body.classList.contains('dark') ||
                          document.body.classList.contains('theme-dark');
        
        const gradient = ctx.createLinearGradient(0, 0, width, 0);
        if (isDarkMode) {
            gradient.addColorStop(0, '#8667cf');
            gradient.addColorStop(0.5, '#F5C5FF');
            gradient.addColorStop(1, '#6146a1');
        } else {
            gradient.addColorStop(0, '#765CBD');
            gradient.addColorStop(0.5, '#3F2D6F');
            gradient.addColorStop(1, '#321A6C');
        }

        const centerBar = Math.floor(numBars / 2);
        const now = Date.now() / 350;
        const propagationSpeed = 0.06;
        const amplitudeBoost = 1.5;
        
        for (let i = 0; i < numBars; i++) {
            let distanceFromCenter = Math.abs(i - centerBar);
            const propagationDelay = distanceFromCenter * propagationSpeed;
            const phase = now - propagationDelay;
            const wave = Math.abs(Math.sin(phase));
            const dataIdx = Math.floor(distanceFromCenter * (this.dataArray.length / centerBar));
            let amplitude = this.dataArray[dataIdx] / 255;
            amplitude *= wave * amplitudeBoost;
            amplitude = Math.min(amplitude, 1);
            const barHeight = amplitude * maxBarHeight;
            const dotSpacing = barHeight / numDots;
            for (let j = 0; j < numDots; j++) {
                if ((j + 1) * dotSpacing > barHeight) break;
                const y = height - (j + 1) * dotSpacing - 4;
                if (y < 0) continue;
                ctx.beginPath();
                ctx.arc(i * barWidth + barWidth / 2, y, barWidth * 0.08, 0, 2 * Math.PI);
                ctx.fillStyle = gradient;
                ctx.globalAlpha = isDarkMode ? 
                    (0.9 - (j / numDots) * 0.3) : 
                    (0.8 - (j / numDots) * 0.5);
                ctx.fill();
            }
        }
        ctx.globalAlpha = 1.0;
        ctx.restore();
    }
}

let audioRecorder = null;

function findTextareaContainer() {
    const activeChats = document.querySelectorAll('.chat-group-container[style*="display: block"], .chat-group-container:not([style*="display: none"])');
    
    for (const chatContainer of activeChats) {
        const textareaContainer = chatContainer.querySelector('#textarea-container .flex.w-full') || 
                                 chatContainer.querySelector('#textarea-container div.flex'); 
        
        if (textareaContainer) {
            return textareaContainer;
        }
    }
    
    const newChatContainer = document.querySelector('form#openai_generator_form #textarea-container .flex.w-full') ||
                             document.querySelector('form#openai_generator_form #textarea-container div.flex');
    
    if (newChatContainer) {
        return newChatContainer;
    }
    
    const textarea = document.querySelector('#chat-textarea-input, #chat_input_textarea, .auto-resize-textarea');
    if (textarea) {
        const parentContainer = textarea.closest('div.flex');
        if (parentContainer) {
            return parentContainer;
        }
    }
    
    return null;
}

function showRecordingInterface(event) {
    document.querySelectorAll('.extra-fields-container').forEach(el => el.classList.add('hidden'));
    if (event) {
        event.preventDefault();
        event.stopPropagation();
    }
    const existingInterface = document.querySelector('.audio-recording-interface');
    if (existingInterface) {
        existingInterface.remove();
    }
    
    let activeContainer = null;
    
    const activeChat = document.querySelector('.chat-group-container[style*="display: block"], .chat-group-container:not([style*="display: none"])');
    if (activeChat) {
        activeContainer = activeChat.querySelector('#textarea-container');
    } else {
        activeContainer = document.querySelector('form#openai_generator_form #textarea-container');
    }
    
    if (!activeContainer) {
        const errorMsg = __('Could not start recording. Please try again.');
        showToast(errorMsg, 'error');
        return;
    }
    
    activeContainer.classList.add('audio-recorder-rounded-bottom');
    const originalContent = activeContainer.innerHTML;
    activeContainer.setAttribute('data-original-content', originalContent);
    
    const recordingInterface = `
        <div class="audio-recording-interface flex w-full items-center p-2 gap-3 rounded-[24px] dark:!bg-[#1a1d23]">
            <div class="visualizer-container flex-grow h-16" style="background: transparent; border: 2px solid transparent; border-radius: 9999px; overflow: hidden; display: flex; align-items: center;">
                <canvas id="audio-visualizer" class="w-full h-full dark:!bg-transparent" style="border-radius: 9999px !important; background: transparent; display: block; width: 100%; height: 100%;" width="586" height="60"></canvas>
            </div>
        </div>
        <div class="flex items-center w-full !bg-white dark:!bg-transparent px-2 min-h-[48px] rounded-b-[8px] flex-wrap extra-fields-container pb-2"
             style="display: flex; justify-content: flex-end; border-radius: 60px !important;">
            <div class="timer-container flex-shrink-0" style="width: 70px; text-align: center; align-items: flex-end; display: flex;">
                <div id="recording-timer" class="dark:!text-[#e2e2e2]" style="font-family: inherit; font-size: 18px; font-weight: 400; color: #565B67; line-height: 1;">00:00</div>
            </div>
            <div class="controls-container flex-shrink-0 flex items-center gap-2" style="margin-top: 0; align-items: flex-end;">
                <button type="button" id="cancel-recording" class="btn !bg-[var(--tblr-danger)] control-btn rounded-full p-0 !text-white shadow-none flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
                <button type="button" id="pause-recording" class="btn btn-secondary !bg-[var(--tblr-secondary)] control-btn rounded-full p-0 !text-white shadow-none flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
                </button>
                <button type="button" id="resume-recording" class="btn btn-secondary !bg-[var(--tblr-secondary)] control-btn rounded-full p-0 !text-white shadow-none flex items-center justify-center" style="display: none;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                </button>
                <button type="button" id="send-recording" class="btn !bg-[var(--tblr-primary)] control-btn rounded-full p-0 !text-white shadow-none flex items-center justify-center" disabled="disabled" title="${__('Recording too short (minimum 5 seconds). 5 second(s) left.')}">
                    <svg xmlns="http://www.w3.org/2000/svg" width="19" height="19" viewBox="0 0 19 19" fill="none">
                        <g clip-path="url(#clip0_5419_54436)">
                            <path d="M9.5 14.75V4.25" stroke="#fff" stroke-width="1.125" stroke-linecap="round" stroke-linejoin="round"></path>
                            <path d="M5 8.75L9.5 4.25" stroke="#fff" stroke-width="1.125" stroke-linecap="round" stroke-linejoin="round"></path>
                            <path d="M14 8.75L9.5 4.25" stroke="#fff" stroke-width="1.125" stroke-linecap="round" stroke-linejoin="round"></path>
                        </g>
                        <defs>
                            <clipPath id="clip0_5419_54436">
                                <rect width="18" height="18" fill="white" transform="translate(0.5 0.5)"></rect>
                            </clipPath>
                        </defs>
                    </svg>
                </button>
            </div>
        </div>
    `;
    
    activeContainer.innerHTML = recordingInterface;
    
    initAudioRecording();
    
    const canvas = document.getElementById('audio-visualizer');
    if (canvas) {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
    }
    
    setupRecordingControlsDirectly();
}

function hideRecordingInterface() {
    const recordingInterface = document.querySelector('.audio-recording-interface');
    if (recordingInterface) {
        const container = recordingInterface.closest('#textarea-container');
        
        if (container) {
            const originalContent = container.getAttribute('data-original-content');
            
            if (originalContent) {
                container.innerHTML = originalContent;
                container.removeAttribute('data-original-content');
                const textarea = container.querySelector('#chat_input_textarea, #chat-textarea-input, .auto-resize-textarea');
                if (textarea) {
                    textarea.dispatchEvent(new Event('input', { bubbles: true }));
                }
                if (typeof toggleSendMessageButton === 'function') {
                    toggleSendMessageButton('NEW');
                }
                setTimeout(() => {
                    const generatorForm = document.getElementById('openai_generator_form');
                    if (generatorForm) {
                        if (window.initializeAutoResizeTextareas) {
                            window.initializeAutoResizeTextareas('.auto-resize-textarea', 53);
                        }
                        const textarea = generatorForm.querySelector('#chat_input_textarea, #chat-textarea-input, .auto-resize-textarea');
                        if (textarea) {
                            textarea.addEventListener('keypress', function(ev) {
                                if ((ev.key === 'Enter' || ev.keyCode === 13) && !ev.shiftKey) {
                                    ev.preventDefault();
                                    generatorForm.requestSubmit ? generatorForm.requestSubmit() : generatorForm.submit();
                                }
                            });
                        }
                    }
                    const chatInputForm = document.getElementById('chat-input-form');
                    if (chatInputForm) {
                        const textarea = chatInputForm.querySelector('#chat-textarea-input, #chat_input_textarea, .auto-resize-textarea');
                        if (textarea) {
                            textarea.addEventListener('keypress', function(ev) {
                                if ((ev.key === 'Enter' || ev.keyCode === 13) && !ev.shiftKey) {
                                    ev.preventDefault();
                                    chatInputForm.requestSubmit ? chatInputForm.requestSubmit() : chatInputForm.submit();
                                }
                            });
                        }
                    }
                    initAudioRecordingButtons();
                }, 100);
                container.classList.remove('audio-recorder-rounded-bottom');
            }
        } else {
            recordingInterface.remove();
        }
    }
    
    if (audioRecorder && audioRecorder.isRecording) {
        audioRecorder.cancelRecording();
    }
    
    setTimeout(initAudioRecordingButtons, 100);

    reinitializeReactComponents();

    setTimeout(() => {
        document.querySelectorAll('.extra-fields-container').forEach(el => el.classList.remove('hidden'));
    }, 100);

    document.querySelectorAll('#textarea-container').forEach(el => el.classList.remove('audio-recorder-rounded-bottom'));
}

function initAudioRecording() {
    if (!audioRecorder) {
        audioRecorder = new AudioRecorder();
    } else {
        if (audioRecorder.isRecording) {
            audioRecorder.cancelRecording();
        }
    }
    
    audioRecorder.startRecording();
}

function initAudioRecordingButtons() {
    const audioButtons = document.querySelectorAll('.audio-recording-toggler');
    
    audioButtons.forEach(button => {
        button.removeEventListener('click', showRecordingInterface);
        button.addEventListener('click', showRecordingInterface);
    });
}

function setupMutationObserver() {
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.type === 'childList' || 
                (mutation.type === 'attributes' && mutation.attributeName === 'style')) {
                
                const visibleHistoricChats = document.querySelectorAll('.chat-group-container[data-chat-group]:not([style*="display: none"])');
                if (visibleHistoricChats.length > 0) {
                    initAudioRecordingButtons();
                }
            }
        });
    });
    
    observer.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['style', 'data-chat-active', 'class']
    });
}

function setupAudioRecorderCompatibility() {
    if (typeof MediaRecorder === 'undefined') {
        const browserNotSupportedMsg = __('Your browser does not support audio recording. Please use a newer browser like Chrome, Firefox, or Edge.');
        
        const audioButtons = document.querySelectorAll('.audio-recording-toggler');
        audioButtons.forEach(button => {
            button.addEventListener('click', function() {
                alert(browserNotSupportedMsg);
            });
        });
        return false;
    }
    
    let mimeType = 'audio/webm';
    if (!MediaRecorder.isTypeSupported(mimeType)) {
        mimeType = 'audio/mp4';
        if (!MediaRecorder.isTypeSupported(mimeType)) {
            mimeType = '';
        }
    }
    
    return true;
}

document.addEventListener('DOMContentLoaded', function() {
    const isCompatible = setupAudioRecorderCompatibility();
    
    if (isCompatible) {
        initAudioRecordingButtons();
        
        setupMutationObserver();
        
        setTimeout(initAudioRecordingButtons, 1000);
        setTimeout(initAudioRecordingButtons, 2000);
        
        document.body.addEventListener('click', function(event) {
            if (event.target.closest('.audio-recording-toggler')) {
                const button = event.target.closest('.audio-recording-toggler');
                showRecordingInterface.call(button, event);
            }
        });
    }
});

function showToast(message, type = 'info') {
    if (typeof toastr !== 'undefined') {
        toastr[type](message);
        return;
    }
    
    const toast = document.createElement('div');
    toast.className = `audio-toast fixed top-4 right-4 py-2 px-4 rounded-lg text-white z-50`;
    
    switch (type) {
        case 'success':
            toast.style.backgroundColor = '#4CAF50';
            break;
        case 'error':
            toast.style.backgroundColor = '#F44336';
            break;
        case 'warning':
            toast.style.backgroundColor = '#FF9800';
            break;
        default:
            toast.style.backgroundColor = '#2196F3';
    }
    
    toast.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)';
    toast.style.animation = 'fadeIn 0.3s, fadeOut 0.3s 2.7s';
    toast.style.opacity = '0.9';
    
    const style = document.createElement('style');
    style.textContent = `
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 0.9; transform: translateY(0); }
        }
        @keyframes fadeOut {
            from { opacity: 0.9; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-20px); }
        }
    `;
    document.head.appendChild(style);
    
    toast.textContent = message;
    
    document.body.appendChild(toast);
    setTimeout(() => {
        if (document.body.contains(toast)) {
            document.body.removeChild(toast);
        }
    }, 3000);
}

function setupRecordingControlsDirectly() {
    const cancelButton = document.getElementById('cancel-recording');
    if (cancelButton) {
        cancelButton.onclick = function(e) {
            e.preventDefault();
            e.stopPropagation();
            if (audioRecorder) {
                audioRecorder.cancelRecording();
            }
            hideRecordingInterface();
        };
    }
    
    const pauseButton = document.getElementById('pause-recording');
    if (pauseButton) {
        pauseButton.onclick = function(e) {
            e.preventDefault();
            e.stopPropagation();
            if (audioRecorder && !audioRecorder.isPaused) {
                const paused = audioRecorder.pauseRecording();
                
                if (paused) {
                    pauseButton.style.display = 'none';
                    
                    const resumeButton = document.getElementById('resume-recording');
                    if (resumeButton) {
                        resumeButton.style.display = 'flex';
                    }
                }
            }
        };
    }
    
    const resumeButton = document.getElementById('resume-recording');
    if (resumeButton) {
        resumeButton.onclick = function(e) {
            e.preventDefault();
            e.stopPropagation();
            if (audioRecorder && audioRecorder.isPaused) {
                const resumed = audioRecorder.resumeRecording();
                
                if (resumed) {
                    resumeButton.style.display = 'none';
                    
                    const pauseButton = document.getElementById('pause-recording');
                    if (pauseButton) {
                        pauseButton.style.display = 'flex';
                    }
                    
                } else {
                    audioRecorder.cancelRecording();
                    audioRecorder = new AudioRecorder();
                }
            }
        };
    }

    const sendButton = document.getElementById('send-recording');
    if (sendButton) {
        sendButton.onclick = function(e) {
            e.preventDefault();
            e.stopPropagation();
            if (!audioRecorder) {
                return;
            }
            
            const originalButtonContent = sendButton.innerHTML;
            
            sendButton.innerHTML = `
                <svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
            `;
            sendButton.disabled = true;
            
            audioRecorder.stopRecording();
                        
            setTimeout(async () => {
                const audioBlob = audioRecorder.getAudioBlob();
                
                if (audioBlob) {
                    try {
                        const timestamp = new Date().getTime();
                        
                        const fileExtension = audioBlob.type.includes('webm') ? 'webm' : (audioBlob.type.includes('mp3') ? 'mp3' : 'wav');
                        const fileName = `audio-message-${timestamp}.${fileExtension}`;
                        const audioFile = new File([audioBlob], fileName, { type: audioBlob.type });
                        
                        const formData = new FormData();
                        formData.append('audio_file', audioFile);
                        
                        fetch('/dashboard/user/audio/transcribe', {
                            method: 'POST',
                            body: formData,
                            headers: {
                                'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || ''
                            },
                            credentials: 'same-origin'
                        })
                        .then(response => {
                            if (!response.ok) {
                                console.log("!response.ok");
                                throw new Error('Erro ao iniciar transcrição');
                            }
                            return response.json();
                        })
                        .then(data => {
                            if (!data.execution_id) {
                                console.log("execution_id não retornado");
                                throw new Error('execution_id não retornado');
                            }
                            return pollTranscriptionResult(data.execution_id);
                        })
                        .then(transcriptionResult => {

                            hideRecordingInterface();
                            
                            setTimeout(() => {
                                let transcribedText = transcriptionResult.text;
                                
                                if (typeof transcribedText === 'string' &&
                                    transcribedText.startsWith('"') && 
                                    transcribedText.endsWith('"')) {
                                    try {
                                        transcribedText = JSON.parse(transcribedText);
                                    } catch (e) {
                                        console.warn("Failed to parse transcribed text as JSON:", e);
                                    }
                                }
                                
                                if (!transcribedText || typeof transcribedText !== 'string') {
                                    console.error("Invalid transcribed text:", transcribedText);
                                    showToast(__('Error: Invalid transcription result'), 'error');
                                    return;
                                }

                                const success = findAndInsertTextInTextarea(transcribedText);
                                
                                if (success) {
                                    if (typeof toggleSendMessageButton === 'function') {
                                        try {
                                            toggleSendMessageButton('NEW');
                                        } catch (e) {
                                            console.warn("Error calling toggleSendMessageButton:", e);
                                        }
                                    }
                                    
                                    try {
                                        reinitializeReactComponents();
                                    } catch (e) {
                                        console.warn("Error reinitializing React components:", e);
                                    }
                                    

                                } else {
                                    setTimeout(() => {
                                        const retrySuccess = findAndInsertTextInTextarea(transcribedText);
                                        if (retrySuccess) {
                                            if (typeof toggleSendMessageButton === 'function') {
                                                try {
                                                    toggleSendMessageButton('NEW');
                                                } catch (e) {
                                                    console.warn("Error calling toggleSendMessageButton:", e);
                                                }
                                            }
                                        } else {
                                            console.error("Failed to insert text even on retry");
                                            showToast(__('Error: Could not find text input field'), 'error');
                                        }
                                    }, 500);
                                }
                            }, 300);
                        })
                        .catch(error => {
                            console.log(error.message);
                            showToast(__('Error processing audio') + ': ' + error.message + '. ' + __('Try again or record with less background noise.'), 'error');
                            hideRecordingInterface();
                        })
                        .finally(() => {
                            if (sendButton && sendButton.isConnected) {
                                sendButton.innerHTML = originalButtonContent;
                                sendButton.disabled = false;
                            }
                        });
                    } catch (error) {
                        console.log(error.message);
                        hideRecordingInterface();
                        
                        if (sendButton && sendButton.isConnected) {
                            sendButton.innerHTML = originalButtonContent;
                            sendButton.disabled = false;
                        }
                    }
                }
            }, 100);
        };
    }
}

function pollTranscriptionResult(executionId) {
    const maxAttempts = 60;
    let attempts = 0;
    
    return new Promise((resolve, reject) => {
        const checkStatus = () => {
            fetch(`/dashboard/user/audio/transcription-status/${executionId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || ''
                },
                credentials: 'same-origin'
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Erro de servidor: ${response.status} ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.status === 'completed') {
                    if (data.result && data.result.text) {
                        resolve(data.result);
                    } else {
                        reject(new Error(__('Transcription text not found in response')));
                    }
                } else if (data.status === 'failed') {
                    reject(new Error(data.error || __('Audio transcription failed')));
                } else if (attempts < maxAttempts) {
                    attempts++;
                    setTimeout(checkStatus, 1000);
                } else {
                    reject(new Error(__('Audio transcription timeout')));
                }
            })
            .catch(error => {
                console.error('Error checking transcription status:', error);
                
                if (attempts < maxAttempts) {
                    attempts++;
                    const backoffDelay = Math.min(1000 * Math.pow(1.5, Math.floor(attempts / 5)), 5000);
                    setTimeout(checkStatus, backoffDelay);
                } else {
                    reject(new Error(__('Failed to check transcription status') + ': ' + error.message));
                }
            });
        };
        
        checkStatus();
    });
}

function reinitializeReactComponents() {
    setTimeout(() => {
        const allReactComponents = document.querySelectorAll('react-component');
        
        allReactComponents.forEach(el => {
            try {
                if (typeof el.render !== 'function' && window.customElements && window.customElements.upgrade) {
                    window.customElements.upgrade(el);
                }
                
                if (typeof el.render === 'function') {
                    el.render();
                }
            } catch (error) {
                console.warn('Error reinitializing React component:', error);
            }
        });
        
        document.dispatchEvent(new CustomEvent('reactComponentsReinitialized', {
            detail: { timestamp: Date.now() }
        }));
    }, 250);
}

function findAndInsertTextInTextarea(transcribedText) {

    const textareaSelectors = [
        '#chat-textarea-input',
        '#chat_input_textarea', 
        '.auto-resize-textarea',
        '[name="chat_input"]',
        'textarea[placeholder*="message"]',
        'textarea[placeholder*="Message"]',
        'textarea[placeholder*="mensagem"]',
        'textarea[placeholder*="Mensagem"]'
    ];
    
    let textarea = null;
    
    const activeChat = document.querySelector('.chat-group-container[style*="display: block"], .chat-group-container:not([style*="display: none"])');
    if (activeChat) {
        for (const selector of textareaSelectors) {
            textarea = activeChat.querySelector(selector);
            if (textarea) {
                break;
            }
        }
    }

    // Se não encontrou no chat ativo, tentar globalmente
    if (!textarea) {
        for (const selector of textareaSelectors) {
            textarea = document.querySelector(selector);
            if (textarea) {
                console.log("Found textarea globally with selector:", selector);
                break;
            }
        }
    }

    if (textarea) {
        const currentText = textarea.value || '';
        const separator = currentText && !currentText.endsWith(' ') ? ' ' : '';
        textarea.value = currentText + separator + transcribedText;

        textarea.dispatchEvent(new Event('input', { bubbles: true }));
        textarea.dispatchEvent(new Event('change', { bubbles: true }));
        textarea.dispatchEvent(new Event('keyup', { bubbles: true }));
        
        textarea.focus();
        const length = textarea.value.length;
        textarea.setSelectionRange(length, length);
        
        if (textarea.classList.contains('auto-resize-textarea')) {
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
        }
        return true;
    }
    
    return false;
} 