function ModelInfoTooltip() {
    const initialize = (tooltipTrigger) => {
        if (bootstrap.Tooltip.getInstance(tooltipTrigger)) return

        const tooltip = new bootstrap.Tooltip(tooltipTrigger, {
            container: 'body',
            trigger: 'manual',
            placement: 'auto',
            customClass: 'info-tooltip-v2 ' + (tooltipTrigger?.dataset?.bsCustomClass || ''),
            popperConfig: {
                modifiers: [{
                    name: 'applyCustomStyles',
                    enabled: true,
                    phase: 'write',
                    fn: ({ state }) => {
                        const { reference, popper } = state.elements;
                        calculatePosition(reference, popper);
                    }
                }]
            }
        });

        tooltipTrigger.addEventListener('click', () => {
            tooltip.toggle()
            setTimeout(() => {
                if ($('body').hasClass('theme-dark')) {
                    let imageUrl = $('.model-info-card-icon').attr('src');
                    if (imageUrl && !imageUrl.includes('-dark.')) {
                        const [name, extension] = imageUrl.split(/\.(?=[^.]+$)/);
                        const newImageUrl = `${name}-dark.${extension}`;
                        $('.model-info-card-icon').attr('src', newImageUrl);
                    }
                }
            }, 100);
        })

        document.addEventListener('wheel', () => {
            tooltip.hide()
        })

        tooltipTrigger.addEventListener('inserted.bs.tooltip', () => {
            const tooltipElement = getTooltipElementByTrigger(tooltipTrigger);
            tooltipElement.classList.add('invisible')

            document.addEventListener('mousemove', function checkHoverState() {
                if (!tooltipTrigger.matches(':hover') && !document.querySelector(`#${tooltipElement.id}:hover`)) {
                    tooltip.hide();
                    document.removeEventListener('mousemove', checkHoverState);
                }
            });
        })

        tooltipTrigger.addEventListener('shown.bs.tooltip', async () => {
            const tooltipElement = getTooltipElementByTrigger(tooltipTrigger);

            resize(tooltipElement);
            calculatePosition(tooltipTrigger, tooltipElement);
            tooltipElement.classList.remove('invisible');

            tooltipTrigger.addEventListener('mouseover',
                calculatePosition(tooltipTrigger, tooltipElement)
            );

            window.addEventListener('resize',
                calculatePosition(tooltipTrigger, tooltipElement)
            );

            document.addEventListener('click', function hideTooltipByClick(event) {
                if (!tooltipTrigger.contains(event.target)) {
                    tooltip.hide();

                    tooltipTrigger.removeEventListener('mouseover', calculatePosition)
                    window.removeEventListener('resize', calculatePosition)
                    document.removeEventListener('click', hideTooltipByClick);
                }
            });
        })
    }

    const initializeAll = () => {
        [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')).map(function(tooltipTrigger) {
            initialize(tooltipTrigger)
        });
    
        createObserver()
        addStyle()
    }

    const createObserver = () => {
        const observerConfig = {
            childList: true,
            subtree: true
        };

        const observerCallback = function(mutationsList, observer) {
            for (let mutation of mutationsList) {
                if (mutation.type === 'childList') {
                    mutation.addedNodes.forEach(function(node) {
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            if (node.hasAttribute('data-bs-toggle') && node.getAttribute('data-bs-toggle') === 'tooltip') {
                                initialize(node);
                            } else {
                                const tooltipElements = node.querySelectorAll('[data-bs-toggle="tooltip"]')
                                tooltipElements.forEach(function(element) {
                                    initialize(element)
                                });
                            }
                        }
                    });
                }
            }
        };

        const observer = new MutationObserver(observerCallback);
        observer.observe(document.body, observerConfig);
    }

    const getTooltipElementByTrigger = (tooltipTrigger) => {
        return document.querySelector(`.${tooltipTrigger.id}-content`)
    }

    const resize = (tooltipElement) => {
        const tooltipInner = tooltipElement.querySelector(`.tooltip-inner`)
        const tooltipContainer = tooltipInner.querySelector(`.container`);

        if (!tooltipContainer) return;

        const maxWidth = Array.from(tooltipContainer.children)
            .reduce((max, child) => {
                const childWidth = Array.from(child.children)
                    .reduce((sum, grandChild) => {
                        return sum + grandChild.offsetWidth;
                    }, 0);
                return Math.max(max, childWidth, tooltipContainer.offsetWidth)
            }, 0);

        const tooltipElementBorderWidth = parseFloat(getComputedStyle(tooltipElement)['borderWidth']) || 0;
        const tooltipInnerBorderWidth = parseFloat(getComputedStyle(tooltipInner)['borderWidth']) || 0;
        const totalBorderWidth = 2 * (tooltipElementBorderWidth + tooltipInnerBorderWidth);
        const availableWidth = tooltipContainer.offsetWidth - totalBorderWidth;

        const widthDifference = Math.max(0, tooltipInner.offsetWidth - availableWidth);
        const maxAvailableWidth = Math.min(maxWidth, window.innerWidth - widthDifference);
        const width = Math.max(0, Math.ceil(maxAvailableWidth));

        tooltipContainer.style.width = `${width}px`;
    }

    const calculatePosition = (tooltipTrigger, tooltipElement) => {
        const triggerRect = tooltipTrigger.getBoundingClientRect();
        const tooltipRect = tooltipElement.getBoundingClientRect();

        const VIEWPORT = {
            left: window.scrollX,
            top: window.scrollY,
            right: window.scrollX + window.innerWidth,
            bottom: window.scrollY + window.innerHeight
        };

        const LIMIT = {
            left: VIEWPORT.right - tooltipRect.width,
            top: VIEWPORT.bottom - tooltipRect.height
        };

        const positionFunctions = {
            left: () => ({
                left: VIEWPORT.left + triggerRect.left - tooltipRect.width,
                top: Math.min(LIMIT.top, VIEWPORT.top + triggerRect.top + triggerRect.height / 2 - tooltipRect.height / 2)
            }),
            top: () => ({
                left: Math.max(VIEWPORT.left, VIEWPORT.left + triggerRect.left + triggerRect.width / 2 - tooltipRect.width / 2),
                top: VIEWPORT.top + triggerRect.top - tooltipRect.height
            }),
            bottom: () => ({
                left: Math.max(VIEWPORT.left, VIEWPORT.left + triggerRect.left + triggerRect.width / 2 - tooltipRect.width / 2),
                top: VIEWPORT.top + triggerRect.bottom
            }),
            right: () => ({
                left: VIEWPORT.left + triggerRect.right,
                top: Math.max(VIEWPORT.top, Math.min(LIMIT.top, VIEWPORT.top + triggerRect.top + triggerRect.height / 2 - tooltipRect.height / 2))
            }),
            edges: () => ({
                left: VIEWPORT.left,
                top: tooltipRect.bottom - triggerRect.top > 0 ? VIEWPORT.top : LIMIT.top
            })
        };

        const isPositionValid = (pos) => {
            return (
                pos.left >= VIEWPORT.left &&
                pos.left <= LIMIT.left &&
                pos.top >= VIEWPORT.top &&
                pos.top <= LIMIT.top
            );
        };

        const adjustPosition = (pos) => {
            return {
                left: Math.max(VIEWPORT.left, Math.min(pos.left, LIMIT.left)),
                top: Math.max(VIEWPORT.top, Math.min(pos.top, LIMIT.top))
            };
        };

        let pos;
        const positionPriority = ['left', 'top', 'bottom', 'right', 'edges'];
        for (const position of positionPriority) {
            pos = positionFunctions[position]();

            if (isPositionValid(pos)) {
                break;
            }
        }

        pos = adjustPosition(pos);

        tooltipElement.style.position = 'absolute';
        tooltipElement.style.inset = '0px auto auto';
        tooltipElement.style.transform = `translate(${pos.left}px, ${pos.top}px)`;
    }

    const addStyle = () => {
        const style = document.createElement('style');
        style.innerHTML = `
            .info-tooltip-v2 .title-text {
                color: #667085;
                font-family: 'Inter-Bold', sans-serif;
                font-size: 16px;
                line-height: 16px;
                letter-spacing: 0.4px
            }

            .theme-dark .info-tooltip-v2 .title-text {
                color: rgba(255, 255, 255, .7);
            }

            .info-tooltip-v2 .small-text {
                color: #667085;
                font-family: 'Inter-Regular', sans-serif;
                font-size: 12px;
                line-height: 16px;
                letter-spacing: 0.4px;
                font-weight: 400;
            }

            .info-tooltip-v2 .normal-text {
                color: #667085;
                font-family: 'Inter-Regular',
                sans-serif;
                font-size: 14px;
                line-height: 16px;
                letter-spacing: 0.4px;
                font-weight: 400;
            }

            .theme-dark .info-tooltip-v2 .normal-text {
                color: rgba(255, 255, 255, .7);
            }

            .info-tooltip-v2 .tag {
                padding: 3px 7px 3px 7px;
            }

            .info-tooltip-v2 .green-tag {
                background-color: #1CA6851A !important;
                color: #1CA685;
            }
            .info-tooltip-v2 .red-tag {
                background-color: #B82C2C1A !important;
                color: #6D3232;
            }
            .info-tooltip-v2 .yellow-tag {
                background-color: #FBBC041A !important;
                color: #FBBC04;
            }

            .info-tooltip-v2 .grey-tag {
                background-color: rgba(127, 127, 127, 0.2) !important;
                color: rgba(0, 0, 0, 0.5) !important;
            }

            .info-tooltip-v2 .highlighted-row {
                background-color: #F4F4F4
            }

            .theme-dark .info-tooltip-v2 .highlighted-row {
                background-color: rgba(255, 255, 255, 0.08)
            }

            .info-tooltip-v2 .text-null {
                color: #D9D9D9
            }

            .theme-dark .info-tooltip-v2 .text-null {
                color: #3E4146
            }

            .info-tooltip-v2 {
                backdrop-filter: unset  !important;
                border: solid 8px transparent !important;
                border-radius: 0.75rem !important;
                opacity: 1 !important;
            }

            .info-tooltip-v2 > .tooltip-inner {
                background-color: #FFF !important;
                min-width: 320px !important;
                display: inline-table;
            }

            .theme-dark .info-tooltip-v2 > .tooltip-inner {
                background-color: #1F2228 !important;
                color: #667085 !important;
            }
        `;
        document.body.appendChild(style);
    }

    return {
        initialize,
        initializeAll
    };
};